<!DOCTYPE html>
<html>

<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>F.A.L.C.O.N</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="style.css">
    <style>


    </style>
</head>

<body>
    <h1 style="font-size: 48px;">F.A.L.C.O.N</h1>

    <div id="status" class="status">
        Feedback-Assisted Launcher with Control Orientation Network
    </div>

    <button id="start_demo">Initialize</button>


    <div class="data">
        <h3>Analytics</h3>

        <div id="gyroData">
            Alpha (Z-axis): <span id="Orientation_a" class="value">0.00</span>¬∞<br>
            Beta (X-axis): <span id="Orientation_b" class="value">0.00</span>¬∞
        </div>
    </div>
    <div class="log" id="log">
        <div style="color: #888;">Console log will appear here...</div>
    </div>
    <img src="ironman.jpg" alt="Iron Man" style="max-width:300px;">

    <script>
        const sliderContainer = document.getElementById('powerSliderContainer');
        const SEND_DELAY = 100;
        const dataSection = document.getElementById('data');
        const demoButton = document.getElementById("start_demo");
        const hiddenData = document.querySelectorAll(".data");
        const prepMessages = [
            "üîß Calibrating repulsors...",
            "üíª Running Jarvis routines...",
            "‚ö° Charging arc reactor...",
            "üõ∞ Scanning target parameters...",
            "üõ° Engaging nanotech stabilization...",
            "üîç Analyzing trajectory vectors...",
            "üéØ Locking on target..."
        ];

        let prepIndex = 0;
        let prepInterval = null;
        let charIndex = 0;
        let isTyping = false;
        let typingInterval = null; // make sure this is consistent


        function typeNextChar() {
            const statusDiv = document.getElementById('status');
            const currentMessage = prepMessages[prepIndex];

            if (!isTyping) {
                charIndex = 0;
                statusDiv.textContent = '';
                isTyping = true;
            }

            if (charIndex < currentMessage.length) {
                statusDiv.textContent += currentMessage[charIndex];
                charIndex++;
            } else {
                // Finished typing current message, wait then go to next
                isTyping = false;
                prepIndex = (prepIndex + 1) % prepMessages.length;
            }
        }

        function startTypingPrep() {
            typingInterval = setInterval(typeNextChar, 100); // 100ms per character
        }

        function stopTypingPrep() {
            clearInterval(typingInterval);
        }


        let isRunning = false;
        let successCount = 0;
        let failCount = 0;
        let lastSendTime = 0;

        function log(message, type = 'info') {
            const logDiv = document.getElementById('log');
            const time = new Date().toLocaleTimeString();
            const color = type === 'error' ? '#f44336' : type === 'success' ? '#4CAF50' : '#888';
            logDiv.innerHTML = `<div style="color: ${color}">[${time}] ${message}</div>` + logDiv.innerHTML;
            console.log(message);
        }

        function updateStatus(message, className) {
            const statusDiv = document.getElementById('status');
            statusDiv.textContent = message;
            statusDiv.className = 'status ' + className;
        }

        function incrementEventCount() {
            const counter = document.getElementById("num-observed-events");
            counter.innerHTML = parseInt(counter.innerHTML) + 1;
        }

        function updateFieldIfNotNull(fieldId, value, precision = 2) {
            if (value != null) {
                document.getElementById(fieldId).innerHTML = value.toFixed(precision);
            }
        }

        function handleOrientation(event) {
            // Rate limiting: only send if enough time has passed
            const now = Date.now();
            if (now - lastSendTime < SEND_DELAY) {
                return; // Skip this event
            }
            lastSendTime = now;

            const alpha = event.alpha || 0;
            const beta = event.beta || 0;

            updateFieldIfNotNull('Orientation_a', alpha);
            updateFieldIfNotNull('Orientation_b', beta);
            incrementEventCount();

            // Send orientation to Flask server (which forwards to ESP32)
            fetch('/gyro', {  // Relative URL - automatically uses your ngrok domain
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ alpha, beta })
            })
                .then(response => {
                    if (response.ok) {
                        successCount++;
                        document.getElementById('num-success').textContent = successCount;
                        updateStatus('üì° Tracking & sending data...', 'connected');
                    } else {
                        throw new Error(`Server returned ${response.status}`);
                    }
                })
                .catch(err => {
                    failCount++;
                    document.getElementById('num-failed').textContent = failCount;
                    log('POST error: ' + err.message, 'error');
                    updateStatus('‚ö†Ô∏è Tracking but connection error', 'error');
                });
        }

        // iOS permission request
        async function requestPermission() {
            if (typeof DeviceOrientationEvent.requestPermission === 'function') {
                try {
                    const perm = await DeviceOrientationEvent.requestPermission();
                    log('Orientation permission: ' + perm, perm === 'granted' ? 'success' : 'error');
                    return perm === 'granted';
                } catch (err) {
                    log('Permission denied: ' + err, 'error');
                    alert("Permission denied: " + err);
                    return false;
                }
            }
            return true; // Android doesn't need permission
        }
      
        demoButton.onclick = async function (e) {
            e.preventDefault();

            if (isRunning) {
                window.removeEventListener('deviceorientation', handleOrientation);
                demoButton.innerText = "Reinitialize";
                demoButton.classList.remove('stop');
                isRunning = false;
                // Stop typing prep messages
                stopTypingPrep();
                updateStatus('Stopped', '');
                log('Demo stopped');
                // Hide slider
                sliderContainer.style.display = 'none';
            } else {
                const granted = await requestPermission();
                if (!granted) {
                    updateStatus('Permission denied', 'error');
                    return;
                }

                window.addEventListener('deviceorientation', handleOrientation);
                demoButton.innerText = "Fire";
                demoButton.classList.add('stop');
                isRunning = true;

                // Show slider
                sliderContainer.style.display = 'block';

                // Start typing Tony Stark prep messages
                startTypingPrep();
                log('Demo started', 'success');
            }
        }

        // Test connection on load
        fetch('/gyro', { method: 'OPTIONS' })
            .then(() => log('‚úÖ Connected to server', 'success'))
            .catch(() => log('‚ùå Cannot reach server', 'error'));

        // Trigger permission request on first click anywhere (iOS requirement)
        document.body.addEventListener('click', requestPermission, { once: true });
    </script>
</body>

</html>